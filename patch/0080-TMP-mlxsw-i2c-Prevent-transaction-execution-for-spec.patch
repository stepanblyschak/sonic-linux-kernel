From b041f1a4ed2da36a831548d8539e8869cea33b40 Mon Sep 17 00:00:00 2001
From: Vadim Pasternak <vadimp@nvidia.com>
Date: Tue, 31 May 2022 10:27:38 +0300
Subject: [PATCH v4.9 ISSU WA 1/1] TMP: mlxsw: i2c: Prevent transaction
 execution for special chip states

Do not run transaction in cases chip is in reset or in-filed update states.

Signed-off-by: Vadim Pasternak <vadimp@nvidia.com>
---
 drivers/net/ethernet/mellanox/mlxsw/cmd.h |  4 ++++
 drivers/net/ethernet/mellanox/mlxsw/i2c.c | 11 +++++++++++
 2 files changed, 15 insertions(+)

diff --git a/drivers/net/ethernet/mellanox/mlxsw/cmd.h b/drivers/net/ethernet/mellanox/mlxsw/cmd.h
index 0772e4339b33..24a9cd276178 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/cmd.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/cmd.h
@@ -149,6 +149,8 @@ enum mlxsw_cmd_status {
 	MLXSW_CMD_STATUS_BAD_NVMEM	= 0x0B,
 	/* Device is currently running reset */
 	MLXSW_CMD_STATUS_RUNNING_RESET	= 0x26,
+	/* FW ISSU ongoing. */
+	MLXSW_CMD_STATUS_FW_ISSU	= 0x27,
 	/* Bad management packet (silently discarded). */
 	MLXSW_CMD_STATUS_BAD_PKT	= 0x30,
 };
@@ -180,6 +182,8 @@ static inline const char *mlxsw_cmd_status_str(u8 status)
 		return "BAD_NVMEM";
 	case MLXSW_CMD_STATUS_RUNNING_RESET:
 		return "RUNNING_RESET";
+	case MLXSW_CMD_STATUS_FW_ISSU:
+		return "FW_ISSUE_ONGOING";
 	case MLXSW_CMD_STATUS_BAD_PKT:
 		return "BAD_PKT";
 	default:
diff --git a/drivers/net/ethernet/mellanox/mlxsw/i2c.c b/drivers/net/ethernet/mellanox/mlxsw/i2c.c
index e04d521d9376..c2d660372633 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/i2c.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/i2c.c
@@ -62,6 +62,7 @@
  * @core: switch core pointer;
  * @bus_info: bus info block;
  * @block_size: maximum block size allowed to pass to under layer;
+ * @status: status to indicate chip reset or in-service update;
  */
 struct mlxsw_i2c {
 	struct {
@@ -75,6 +76,7 @@ struct mlxsw_i2c {
 	struct mlxsw_core *core;
 	struct mlxsw_bus_info bus_info;
 	u16 block_size;
+	u8 status;
 };

 #define MLXSW_I2C_READ_MSG(_client, _addr_buf, _buf, _len) {	\
@@ -404,6 +406,10 @@ mlxsw_i2c_cmd(struct device *dev, u16 opcode, u32 in_mod, size_t in_mbox_size,

 	WARN_ON(in_mbox_size % sizeof(u32) || out_mbox_size % sizeof(u32));

+	/* Do not run transaction if chip is in reset or in-service update state. */
+	if (mlxsw_i2c->status)
+		return 0;
+
 	if (in_mbox) {
 		reg_size = mlxsw_i2c_get_reg_size(in_mbox);
 		num = reg_size / mlxsw_i2c->block_size;
@@ -478,6 +484,11 @@ mlxsw_i2c_cmd(struct device *dev, u16 opcode, u32 in_mod, size_t in_mbox_size,

 cmd_fail:
 	mutex_unlock(&mlxsw_i2c->cmd.lock);
+	if (*status == MLXSW_CMD_STATUS_FW_ISSU ||
+	    *status == MLXSW_CMD_STATUS_RUNNING_RESET) {
+		mlxsw_i2c->status = *status;
+		err = 0;
+	}
 	return err;
 }

--
2.20.1

